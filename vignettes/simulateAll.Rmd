---
title: "Simluate over All Parameters"
output: html_notebook
---

```{r setup}

# these packages are required but do not need to be loaded.
# If you do load them, MCMCpack has to be loaded before tidyverse
# else it masks an important function select()
# install.packages(c("SIBER", "MCMCpack"))
# library(SIBER)
# library(MCMCpack)

# these packages are required and need to be loaded.
library(tidyverse)
library(magrittr)
library(broom)
library(patchwork)
library(knitr)

# pretty summary table printing these need to be installed, but not loaded
# install.packages("sjplot) # is sufficient to pull the others
# library(sjPlot)
# library(sjmisc)
# library(sjlabelled)




# source the R files while this is not a compiled package
# source("../R/simPopEquilibrium.R")

```


In this file we simulate with variation on all parameters independently. The goal at the end is to test whether the analytical model is capable of explaining the data, and whether correcting for the other paramters can identify the link between variation in diet with variation in consumer isotopes. That is to test whether

$$\sigma_x^2 \propto \sigma_f^2$$

Specifically we simulate data for a single population containing $w$ individuals as follows, and then repeat the process for a number of replicate populations:

The number of sources $K$ is drawn from a uniform distribution within minimum value 2, amd maximum value 20.

$$K \sim \text{unif(2, 20)}$$

A vector of $K$ $\alpha_i$ values is then created which will define the Dirichlet distribution used to generate the populations. In these simulations we set the number of individuals in each population to be constant at $w = 50$. The numbe

$$\log_{10}(\alpha_i) \sim \text{unif}(-1, 2) $$
Values of $\alpha_i = 1$ for all $K$ sources generate a distribution that is flat on the simplex (although the corresponding marginal distributions are not uniform). Values of $\alpha_i$ all close to 0.1 lower the proabbility density in the middle of the simple and elevate the vertices, while values all close to 10 mean that the pdf has a peak in the centre of the simplex and values near the edges and vertices are relatively unlikely. A vector of $alpha_i$ containing a range of values shift the mode and variance of the pdf on the simplex.

The $w$ individuals comprising the population then have a vector of independent Dirichlet distributed dietary proportions $f_i(w)$

$$f_i(w) \sim \text{Dir}(\alpha_1, \alpha_i, \dots, \alpha_K )$$

A matrix of $j = 2$ isotope values for each of the food sources (the baselines) are simulated from a uniform distribution, from 0 to a maximum value that is itself drawn from a uniform distribution. In this way, the range of each population's food sources differ from each other and hence we simulate a range of variances for the baselines. *Note that we could simulate over different numbers of isotopes by altering the code but for now ewe will stick to two isotope tracers.*

$$x^*_{ij} \sim \text{unif}(0, \sim \text{unif}(1, 30))$$

Ultimately, the corresponding isotope values of the population of consumers is given by

$$x(w) = \textbf{F}\textbf{X}^* $$

where $\textbf{F}$ is the $(w \times K)$ matrix of dietary proportions for the entire population $f(w)$ and $\textbf{X*}$ is the $(2 \times K)$ matrix of food source isotope values they consume.

The above procedure is then repeated for each of the 1000 replicate populations.


# Begin Simulations

Define the properties of the consumers

```{r}

# how many populations to simulate
n_pops <- 1000

# how many consumers per population
n_individuals <- 50

# number of food sources they eat from
K <- ceiling(runif(n_pops, min = 2, max = 20 ))

# set how many isotopes are used in each population and create the tibble
iso_tbl <- tibble(n_individuals, K, n_iso = rep(2, n_pops) )

```

## Generate the dietary proportions

```{r}

# K is a vector 1:3
# the alphas are stored in list aa, which can be of unequal length

aa <- 3

# a functino to generate alpha values for input to 
# a corresponding Dirichlet. Values are drawn from a 
# uniform distribution on a log10 scale between 
# min and max as defined in the function call.
generateAlpha <- function(K = 3, min = 0.1, max = 10) {
  
  return(10 ^ runif(K, min = log10(min), max = log10(max)))
  
}


# A function to generate a set of proportions using the 
# alphas defined in generateAlpha
generateProportions <- function(n, K, aa){
  
  return(MCMCpack::rdirichlet(n = n, alpha = aa))
  
}


iso_tbl %<>% mutate(aa = pmap(list(K), generateAlpha, min = 0.1, max = 10 ))

# use cross_df to set up all combinations, but we have to generate an index
# for the list aa and later insert the corresponding values from aa in 
# the tibble and remove the idx column.
# aj <- cross_df(list(idx = 1:4, K = 1:3))
# bb <- aj %>% mutate(alphas = aa[idx]) %>% select(-idx) 

iso_tbl %<>% mutate(p = pmap( list(n = n_individuals, K = K, aa = aa), generateProportions))



```



## Generate the Source isotope values


```{r}

# the max range of the isotopes. Here i am rescaling real isotope values so that
# their S_min is zero. I am imaging these to be d13C and d15N in this example.
# I generate  range of them from 0 to 20 for d13C and 0 to 10 for d15N.


# a wrapper function to pull runifs for the range of source isotoeps
genSourceRange <- function(n_iso, max_val = 30){
  runif(n_iso, min = 1, max = max_val)
  }

# generate maximum source isotope values from which to draw Sources in the  
# subsequent step.
iso_tbl %<>% mutate(S_max = pmap(list(n_iso), genSourceRange, max_val = 30))


# a function to generate the sources by drawing them from runif()
generateSources <- function(K = 3, S_max = c(1, 10), setSeed = NULL, ...){
  
  if(!is.null(setSeed)) {set.seed(setSeed)}
  
  # generate a matrix of runif values
  # with K rows and length(S) columns.
  # Each column i has runif max = S_max[i]
  matrix(runif(n = K * length(S_max), min = 0, max = S_max),
         ncol = length(S_max), byrow = TRUE)
  # print(c(K,S_max))
  
}


# ------------------------------------------------------------------------------

# use pmap to loop over the rows of our tibble, select the K and S_max
# columns and use those to draw a set of runif distributed isotope values for
# each of the K sources and number of isotopes (length of S_max)
iso_tbl %<>% mutate(S = pmap( list(K, S_max), generateSources, setSeed = NULL))



```


## Calculate consumer isotope values

A function to generate the consumer isotope values

```{r}
simPopEquilibrium <- function(p = MCMCpack::rdirichlet(1, rep(1, 3)),
                              S = matrix(runif(6, min = -10, max = 0),
                                         nrow = 3, ncol = 2), TDF = 0, ...) {

  

  # Calculate the Stable isotope values of the consumers as a
  # p weighted sum of food source isotoep values (S) after applying the
  # Trophic Discrimination factor (TDF)
  consumerIso <- p %*% (S + TDF)

  return(consumerIso)
}

```


```{r}

# call the function simPopEquilibrium which we sourced from "R/" directory
# in the setup chunk. This function calculates the consumer isotope values.
# This function is mapped over each row in our dataset.
iso_tbl %<>% mutate(X = pmap(list(p, S), simPopEquilibrium))


```


# Calculate Variances of the Simulated Data

This function below allows us to calculate the mean, variance and covariance of the dirichlet distribution used to simulate each population's dietary proportions. *Currently not used in subsequent analyses.*

```{r dirichlet-moments}

# given a vector of alphas calculate the first moments
dirichletMomentsAlphas <- function(aa) {
  
  a_0 <- sum(aa)
  
  # the mean
  mu_X <- aa / a_0
  
  # variance
  var_X <- aa * (aa - a_0) / (a_0^2 * (a_0 + 1))
  
  # covariance
  a_ij <- aa %*% t(aa)
  diag(a_ij) <- 0 # set i=j to zero
  
  cov_X <- -a_ij / (a_0^2 * (a_0 + 1))
  
  return(list(mu_X, var_X, cov_X))
  
  
}
  

# test the function
# dirichletMomentsAlphas(rep(3, 5))
                        
```


There are numerous ways in which variance can be calculated on these multivariate data. In particular the dietary proportions causes most difficulty owing to the strict negative covariances on the simplex. The approach taken currently is to calculate the sum of the marginal variances only; i.e. to ignore the off-diagonal covariances (this is the Trace of the matrix of dietary proportions $\text{tr}(\textbf{F})$).

We also calculate some statistical descriptors of the variance among consumer isotope values within each simulated popultion. The Standard Ellipse Area (SEA) is calculated here but currently not used in the visualisations below (*incidentally its interesting how SEA does not correlate well with \sigma_x*). The total variance among consumers' isotope values withiin a population is calculated as the sum of the covariance matrix of the samples $\hat{\sigma_x} = \sum\text{cov(x)}$.

The total variance of the isotope food sources for each population is calculated in the same way $\hat{\sigma_{x^*}} = \sum\text{cov}(x^*)$.



```{r}

# The Trace (sum of the diagonal) of the covariance matrix of the 
# dietary proportions. Which will approximate the sample estimate
iso_tbl %<>% 
  mutate(p_trace = pmap(list(p), ~unlist(sum(diag(cov(.))))) %>% unlist)

# calculate covariance of the p-1 dietary proportions.
iso_tbl %<>% 
  mutate(cov_p_1 = pmap(list(p), ~unlist(sum((cov(.[,-1]))))) %>% unlist)


# calculate the area of the Standard Ellipse Area of the isotope data
# NB only works in two dimensions for SIBER but it can easily be 
# extended to Z dimensions. We use an internal if() statement to check 
# before calculating the area, else it returns NA.
doSEA <- function(x) {
  if(ncol(x) == 2) {
    out <- SIBER::sigmaSEA(cov(x))$SEA
  
  } else {
  out <- NA
  }
  return(out)
}

# map this function over all rows of our tibble
iso_tbl %<>% 
  mutate(SEA = pmap(list(X), ~doSEA(.)) %>% unlist,
         X_var = pmap(list(X), ~sum(cov(.))) %>% unlist)


# calculate sum of the covariance matrix of the food sources mapped over
# each row.
iso_tbl %<>% 
  mutate(S_var = pmap(list(S), ~sum(cov(.))) %>% unlist)

```


## Plot marginal effects of each variable

Since we simulated our data with across independent random draws of $K$, $\sigma_{x^*}$ and $\sigma_f$, we can explore the relationships between the observed consumer isotope variation $\hat{\sigma}_x$ and the observed statistical approximations of these simulated processes. We can also attempt to correct for "nuisance" effects of differing baselines or numbers of sources in order to focus on revealing the key effect of diet variation on consumer isotope variation.

### Effect of baseline variation $\sigma_{x^*}$.

```{r}
g1 <- ggplot(data = iso_tbl, 
             mapping = aes(x = S_var, y = X_var )) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  scale_x_log10() + 
  scale_y_log10()

# and a linear model
m1 <- glm(log(X_var) ~ log(S_var), data = iso_tbl)

# the sjPlot::tab_model() function is not outputting to Rnotebook
# m2 %>% sjPlot::tab_model()

# summary(m2)

# create a similar plot but remove marginal effects of other 
# variables K and cov_p_1
g1_corrected <- g1 + aes(y =  X_var / ((K-1) * cov_p_1 )) + 
  geom_abline(slope = 1, intercept = 0, color = "red")
# print(g1_corrected)

```


### Effect of number of sources $K$.

```{r}
# Create a new tibble to allow us to 
# add the line representing how X_var should scale with K
K_line <- tibble(K = min(iso_tbl$K):max(iso_tbl$K))
K_line %<>% mutate(X_var = K-1)


# calculate the effect of K on X_var according to the model
# for our simualted data
iso_tbl %<>% mutate(K_effect = K - 1)

# fit a linear model
m2 <- glm(log(X_var) ~ log(K_effect), data = iso_tbl)

g2 <- ggplot(data = iso_tbl, 
             mapping = aes(x = K, y = X_var)) + 
  geom_point() + 
  geom_smooth(method = "lm") +
  geom_line(data = K_line, 
            mapping = aes(x = K, 
                          y = X_var), 
            color = "red") + 
  scale_x_log10() + 
  scale_y_log10()

# similar plot correct for S_var and cov_p_1
g2_corrected <- g2 + aes(y = X_var / (S_var * cov_p_1))

```

Print both side by side

```{r}
(g1 | g1_corrected)

ggsave(plot = (g1|g1_corrected), filename = "effect-of-S_var.eps")

```

**Figure 1.** The relationship between the observed consumer isotope variation $\hat{\sigma}^2_x$ and the marginal effects of source isotope variation $\sigma^2_{x^*}$  in **a** and number of food sources $K$ in **b**. The blue line in **a** is a regression line fitted to the data, and the red line in **b** is the analytical predicted relationship of $\hat{\sigma}^2_x = (K-1)$.

```{r}
(g2 | g2_corrected)

ggsave(plot = (g2|g2_corrected), filename = "effect-of-K.eps")
```


### Correct for $\sigma_{x^*}$ and $K$.

Here we show the relationship between diet variation as quantified by the Trace of each population's matrix of dietary proportions with the uncorrected consumer isotope variance $\hat{\sigma}^2_x$ but also a corrected version ( $\hat{\sigma}^\dagger_x$) that accounts for the predicted relationship of $K$ and $\sigma^2_{x^*}$

$$\hat{\sigma}^{2\dagger}_x = \frac{\hat{\sigma}^2_x}{\sigma^2_{x^*}(K-1)}$$

It is important to note that our current use of $\text{tr}(\textbf{F})$ to represent variation in dietary proportions does not map perfectly onto the mathematical model which decomposes variation into $\sigma_f^2$ and $(1-\tau)$. As a result, $\text{tr}(\textbf{F})$ is likely to not fully capture the predicted relationship from the analytical model. *We need to think about this some more and probably chat with Jeff*.


```{r}

# uncorrected X_var
g3 <- ggplot(data = iso_tbl, 
             mapping = aes(x = p_trace,
                           y = X_var)) + 
  geom_point() + 
  geom_smooth(method = "lm")


# corrected X_var
g4 <- ggplot(data = iso_tbl, 
             mapping = aes(x = p_trace,
                           y = X_var / ( S_var * (K-1)))) + 
  geom_point() + 
  geom_smooth(method = "lm")+
  geom_abline(intercept = 0, slope = 1, color = "red")




```

```{r}

# print both side by side
(g3 | g4)

ggsave(plot = (g3|g4), filename = "effect-of-diet-ptrace.eps")
```



**Figure 2.** The relationship between simulated consumer isotope variation (X_var = $\hat{\sigma}^2_x$) in **a**, and corrected isotope variation (X_var_corrected = $\hat{\sigma}^{2\dagger}_x$) in **b** against dietary variation (p_trace = $\text{tr}(\textbf{F})$ . The blue regression line in **a** is a linear fit, while the red line in **b** is the analytical prediction for a 1:1 scaling relationship.


## Correlation between cov(p[-1]) and X_var

```{r}
# uncorrected X_var
g5 <- ggplot(data = iso_tbl, 
             mapping = aes(x = cov_p_1,
                           y = X_var)) + 
  geom_point() + 
  geom_smooth(method = "lm")


# corrected X_var
g5_corrected <- ggplot(data = iso_tbl, 
             mapping = aes(x = cov_p_1,
                           y = X_var / ((K-1) * S_var ))) + 
  geom_point() + 
  geom_smooth(method = "lm") +
  geom_abline(intercept = 0, slope = 1, color = "red") + 
  scale_x_log10() +
  scale_y_log10()


```

```{r}

# print both side by side
(g5 | g5_corrected)

ggsave(plot = (g5|g5_corrected), filename = "effect-of-diet-covar.eps")
```




### Fit a linear model for all the variables

The prediction from a log-log regression model would be that the coefficients are all equal to 1. This is because on a log-log scale, the multiplicative relationships become additive.

```{r}

m5 <- glm(log(X_var) ~ log(I(K-1)) + log(S_var) + log(cov_p_1), data = iso_tbl)

m5 %>% tidy() %>% kable(digits = 2)
```


While S_var is coming out with a scaling of 1:1 with X_var, the relationship with number of sources (K-1) is not matching well the predicted relationship, and is in fact negative. It is possible that this is arising due to us not correcting for diet variation in this model, and my understanding is that a Dirichlet distribution is going to change the estimated diet variation in a confounded way with the number of food sources, and my sense is that i would expect diet variation and hence consumer isotope variation to decrease with number of sources. *We should chat with Jeff about this as my feeling is that it is a consequence of the way we are simulating the data from the dirichlet distribution.*


### Plot including all variables

```{r}

g6 <- ggplot(data = iso_tbl, 
             mapping = aes(x = S_var * (K-1) * cov_p_1,
                           y = X_var)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  geom_abline(slope = 1, intercept = 0, color = "red") + 
  scale_x_log10() + 
  scale_y_log10()

print(g6)

```
