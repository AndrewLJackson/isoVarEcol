---
title: "Ex 1: Wolves"
output: html_notebook
---


### Load MixSIAR package

```{r}
library(MixSIAR)
```

### Load mixture data

```{r}
# Replace the system.file call with the path to your file
# mix.filename <- system.file("wolves/wolves_consumer.csv")

# Load the mixture/consumer data for all regions
mix_all <- load_mix_data(
  filename="wolves/wolves_consumer.csv", 
  iso_names=c("d13C","d15N"), 
  factors=c("Pack","Region"), 
  fac_random=c(TRUE,TRUE), 
  fac_nested=c(FALSE,TRUE), 
  cont_effects=NULL)

raw_wolves_consumer_all_data <- read.csv(file = "wolves/wolves_consumer.csv", header = TRUE)


# Load the mixture/consumer data for region 1 
mix_1 <- load_mix_data(
  filename="wolves/wolves_consumer_region_1.csv", 
  iso_names=c("d13C","d15N"), 
  factors=c("Pack","Individual"), 
  fac_random=c(TRUE,TRUE), 
  fac_nested=c(FALSE,TRUE), 
  cont_effects=NULL)

# Load the mixture/consumer data for region 1 
mix_2 <- load_mix_data(
  filename="wolves/wolves_consumer_region_2.csv", 
  iso_names=c("d13C","d15N"), 
  factors=c("Pack","Individual"), 
  fac_random=c(TRUE,TRUE), 
  fac_nested=c(FALSE,TRUE), 
  cont_effects=NULL)


# Load the mixture/consumer data for region 1 
mix_3 <- load_mix_data(
  filename="wolves/wolves_consumer_region_3.csv", 
  iso_names=c("d13C","d15N"), 
  factors=c("Pack","Individual"), 
  fac_random=c(TRUE,TRUE), 
  fac_nested=c(FALSE,TRUE), 
  cont_effects=NULL)

```

### Load source data


```{r}
# Replace the system.file call with the path to your file
source.filename_1 <- "wolves/wolves_sources_region_1.csv"

# Load the source data
source_1 <- load_source_data(filename=source.filename_1,
                           source_factors=NULL, 
                           conc_dep=FALSE, 
                           data_type="means", 
                           mix_1)

# Replace the system.file call with the path to your file
source.filename_2 <- "wolves/wolves_sources_region_2.csv"

# Load the source data
source_2 <- load_source_data(filename=source.filename_2,
                           source_factors=NULL, 
                           conc_dep=FALSE, 
                           data_type="means", 
                           mix_2)

# Replace the system.file call with the path to your file
source.filename_3 <- "wolves/wolves_sources_region_3.csv"

# Load the source data
source_3 <- load_source_data(filename=source.filename_3,
                           source_factors=NULL, 
                           conc_dep=FALSE, 
                           data_type="means", 
                           mix_3)
```

### Load discrimination data

Same TDFs for all regions.

```{r}
# Replace the system.file call with the path to your file
discr.filename <- "wolves/wolves_discrimination.csv"

# Load the discrimination/TDF data
discr <- load_discr_data(filename=discr.filename, mix_1)
```

### Plot data

```{r, eval=TRUE}
# Make an isospace plot
plot_data(filename="isospace_plot", plot_save_pdf=FALSE, plot_save_png=FALSE, mix_1,source_1,discr)
```


### Plot prior

Define your prior, and then plot using "plot_prior"

+ RED = your prior
+ DARK GREY = "uninformative"/generalist (alpha = 1)
+ LIGHT GREY = "uninformative" Jeffrey's prior (alpha = 1/n.sources)

Bayesian analyses require priors, and MixSIAR includes a `plot_prior` function to plot the prior on the mixture (diet) proportions (at the highest hierarchical level, p.global). The prior represents our knowledge about the proportions before we consider the biotracer data. A natural tendency is to want a flat/"uninformative" prior, where all values between 0 and 1 are equally likely. However, because proportions are not independent, there is no truly uninformative prior (e.g. the histograms are not flat). The best we can do with the Dirichlet distribution is set $\alpha$ = c(1,1,1), which is uninformative on the simplex. In other words, all combinations of the proportions are equally likely. See the section titled "Constructing informative Bayesian priors" in the forthcoming MixSIAR paper.

Because the mean of the "uninformative" prior, $\alpha$ = c(1,1,1), is $\frac{1}{n.sources}$, we also call it the generalist prior. This reflects two facts: 1) it is not really uninformative, and 2) for weakly informative data it shifts the posterior towards a generalist diet, $p_1 = p_2 = p_3 = \frac{1}{3}$. The amount of shift depends on the informativeness of the data (quality, quantity, and polygon geometry).

```{r, eval=FALSE}
# default "UNINFORMATIVE" / GENERALIST prior (alpha = 1)
plot_prior(alpha.prior=1,source)
```

### Write JAGS model file
    
Write the JAGS model file (define model structure). The model will be saved as `model_filename` ("MixSIAR_model.txt" is default, but you may want to change if you create many different models).

There are 3 error term options available:

1. Residual * Process (`resid_err = TRUE`, `process_err = TRUE`)
2. Residual only (`resid_err = TRUE`, `process_err = FALSE`)
3. Process only (`resid_err = FALSE`, `process_err = TRUE`)

In the Wolves Example we want the "Residual * Process" error option. The differences between "Residual * Process", "Residual only", and "Process only" are explained in [Stock and Semmens (2016)](https://doi.org/10.1002/ecy.1517).

**Note:** If you have only 1 mix datapoint (or 1 mix datapoint per factor level, i.e. region or pack in this example), you have no information about the mixture/consumer variability. In this case, we use the original MixSIR error model (which does not fit a residual error term). This is the same behavior as `siarsolo` in SIAR.

```{r, eval=TRUE}
# Write the JAGS model file
model_filename_1 <- "MixSIAR_model_1.txt"   # Name of the JAGS model file

model_filename_2 <- "MixSIAR_model_2.txt"   # Name of the JAGS model file

model_filename_3 <- "MixSIAR_model_3.txt"   # Name of the JAGS model file


write_JAGS_model(model_filename_1, 
                 resid_err = FALSE, 
                 process_err = TRUE, 
                 mix_1, source_1)

write_JAGS_model(model_filename_2, 
                 resid_err = FALSE, 
                 process_err = TRUE, 
                 mix_2, source_2)

write_JAGS_model(model_filename_3, 
                 resid_err = FALSE, 
                 process_err = TRUE, 
                 mix_3, source_3)
```

### Run model

Choose one of the MCMC run options:

| run ==  | Chain Length | Burn-in | Thin | # Chains |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| "test" | 1,000 | 500 | 1 | 3 |
| "very short" | 10,000 | 5,000 | 5 | 3 |
| "short" | 50,000 | 25,000 | 25 | 3 |
| "normal" | 100,000 | 50,000 | 50 | 3 |
| "long" | 300,000 | 200,000 | 100 | 3 |
| "very long" | 1,000,000 | 500,000 | 500 | 3 |
| "extreme" | 3,000,000 | 1,500,000 | 500 | 3 |

You can also set custom MCMC parameters, e.g:
```{r, eval=FALSE}
# run <- list(chainLength=200000, burn=150000, thin=50, chains=3, calcDIC=TRUE)
```


After a test run works, increase the MCMC run to a value that may converge
```{r, eval=FALSE}
jags_region_1 <- run_model(run="normal", mix_1, source_1, discr, model_filename_1)

save(jags_region_1, 
     file = "wolves-normal-process-only-region-1.RData",
     compress = "xz")

jags_region_2 <- run_model(run="normal", mix_2, source_2, discr, model_filename_2)

save(jags_region_2, 
     file = "wolves-normal-process-only-region-2.RData",
     compress = "xz")

jags_region_3 <- run_model(run="normal", mix_3, source_3, discr, model_filename_3)

save(jags_region_3, 
     file = "wolves-normal-process-only-region-3.RData",
     compress = "xz")

```

```{r debug-notes, eval=FALSE}

# from process only
 # process.var[iso,i] <- inprod(1/src_tau[,iso],p2[i,]) + 
 #  inprod(frac_sig2[,iso],p2[i,]);

# from process & residual
# process.var[iso,i] <- inprod(1/src_tau[,iso,Factor.1[i]],p2[i,]) + inprod(frac_sig2[,iso],p2[i,]);


```


`jags.1` will be an `rjags` object where you can access the MCMC chains for plotting, aggregating sources a posteriori, etc.


